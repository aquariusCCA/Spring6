---
up:
  - "[[Spring Framework的特点]]"
---
# 1. 定義

* **領域模型（Domain Model）**
  用類與物件抽象並表達業務領域的**核心概念、規則與行為**。

  * 專注於業務邏輯與不變條件（Invariants）
  * 與技術框架、資料庫結構解耦
  * 以業務語言（Ubiquitous Language）命名

* **PO（Persistence Object）**
  為**資料庫持久化**而存在的資料結構，通常對應資料表的一筆記錄。

  * 關注欄位型別、主鍵、索引等
  * 通常是純資料結構（POJO）
  * 不包含業務規則

---

# 2. 差異比較

| 項目       | 領域模型              | PO         |
| -------- | ----------------- | ---------- |
| 核心關注     | 業務規則與行為           | 資料庫映射      |
| 狀態轉移檢查   | 放在方法內             | 無          |
| 對應對象     | 真實世界業務概念          | 資料表欄位      |
| 是否依賴 ORM | 不一定（可用 Mapper 分離） | 通常直接依賴     |
| 可否重用     | 高，可測試             | 較低，依賴資料庫結構 |

---

# 3. 貧血模型 vs 富含領域邏輯的模型

* **貧血模型（Anemic Model）**：
  PO 只有 getters/setters，所有規則散落在 Service，易導致維護困難。
* **充血模型（Rich Model）**：
  PO（或領域實體）內封裝規則與行為，狀態變更透過方法進行。

---

# 4. 關係模式

* **簡單系統**：PO 與領域實體可合併為同一類（務實做法）
  前提：規則少、CRUD 為主、可接受 ORM 註解耦合
* **複雜系統**：PO 與領域實體分離

  * 使用 Mapper/Assembler 轉換
  * 隱藏資料庫結構與持久化細節
  * 提升模型演進彈性

---

# Controller / Service / DAO 與領域模型互動

## 1. 責任劃分

* **Controller（輸入輸出層）**

  * 接收請求、驗證基本參數、轉換為 DTO
  * 呼叫 Service
  * 回傳統一格式的 Response
  * **不處理業務規則**

* **Service（應用層）**

  * 編排流程（Process Orchestration）
  * 控制交易邊界（`@Transactional`）
  * 載入/保存領域模型（透過 Repository）
  * 呼叫領域模型方法執行規則檢查
  * **不直接寫 SQL**

* **DAO / Repository（基礎層）**

  * 對資料庫的 CRUD 操作
  * 與 PO 交互（JPA/MyBatis）
  * Repository 使用**領域語言**返回聚合根，DAO 負責實際查表

* **領域模型（Domain Entity/Value Object）**

  * 封裝狀態與行為
  * 實作業務規則、不變條件檢查
  * 不依賴框架與資料庫 API

## 2. 呼叫流程範例

1. **Controller** 接收 `/api/orders` 請求，轉成 `CreateOrderCommand`
2. **Service** 開啟交易 → 建立 `Order` 實體（領域模型）
3. 呼叫 `order.addItem(...)` → **領域模型檢查規則**
4. **Service** 呼叫 `OrderRepository.save(order)`
5. **Repository** 透過 **DAO** 將領域模型轉為 PO 並存入資料庫
6. Controller 回傳結果

## 3. 互動示意圖

```
[Controller]
   ↓ (DTO)
[Service / Application Layer]
   ↓ (Domain Model)
[Domain Entity / Value Object]
   ↑ ↓
[Repository Interface] ←→ [DAO / PO / SQL]
```

## 4. 實務準則

1. **能放進實體的不變條件，絕不放在 Service**
2. **應用層不做細節計算，只負責編排與交易控制**
3. **Repository 用業務語言，DAO 用資料庫語言**
4. **避免暴露可變集合與無限制的 setter**
5. **簡單案子 PO = Domain Entity；複雜案子分離並用 Mapper 對應**

---

# 5. 最小 Java 範例（Java 8）

### 領域實體

```java
public class Order {
    private Long id;
    private Long customerId;
    private OrderStatus status = OrderStatus.NEW;
    private final List<OrderItem> items = new ArrayList<>();

    public static Order create(Long customerId) {
        if (customerId == null) throw new IllegalArgumentException("customerId 必填");
        Order order = new Order();
        order.customerId = customerId;
        return order;
    }

    public void addItem(Long productId, BigDecimal price, int qty) {
        if (status != OrderStatus.NEW) throw new IllegalStateException("只有 NEW 可加項目");
        if (price.signum() <= 0 || qty <= 0) throw new IllegalArgumentException("商品價格或數量錯誤");
        items.add(new OrderItem(productId, price, qty));
    }

    public void pay() {
        if (status != OrderStatus.NEW) throw new IllegalStateException("狀態錯誤");
        if (items.isEmpty()) throw new IllegalStateException("空單不可付款");
        status = OrderStatus.PAID;
    }
}
```

### Service

```java
@Service
public class OrderService {
    private final OrderRepository repo;
    public OrderService(OrderRepository repo) { this.repo = repo; }

    @Transactional
    public Long createOrder(Long customerId) {
        Order order = Order.create(customerId);
        return repo.save(order);
    }
}
```

### Controller

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    private final OrderService service;
    public OrderController(OrderService service) { this.service = service; }

    @PostMapping
    public ResponseEntity<?> create(@RequestBody CreateOrderRequest req) {
        Long id = service.createOrder(req.customerId);
        return ResponseEntity.ok(id);
    }
}
```

---

# 6. 複雜案子：分離 PO 與領域模型，並用 Mapper 對應

### 資料表

```sql
CREATE TABLE orders (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  customer_id BIGINT NOT NULL,
  status VARCHAR(20) NOT NULL,
  created_at DATETIME NOT NULL
);

CREATE TABLE order_item (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  order_id BIGINT NOT NULL,
  product_id BIGINT NOT NULL,
  unit_price DECIMAL(18,2) NOT NULL,
  quantity INT NOT NULL
);
```

### PO（持久化對象）

```java
public class OrderPO {
    private Long id;
    private Long customerId;
    private String status;
    private LocalDateTime createdAt;
    // getters/setters
}

public class OrderItemPO {
    private Long id;
    private Long orderId;
    private Long productId;
    private BigDecimal unitPrice;
    private int quantity;
    // getters/setters
}
```

### 領域模型

```java
public class Order {
    private Long id;
    private Long customerId;
    private OrderStatus status;
    private LocalDateTime createdAt;
    private final List<OrderItem> items = new ArrayList<>();

    public static Order create(Long customerId) {
        if (customerId == null) throw new IllegalArgumentException("customerId 必填");
        Order order = new Order();
        order.customerId = customerId;
        order.status = OrderStatus.NEW;
        order.createdAt = LocalDateTime.now();
        return order;
    }

    public void addItem(Long productId, BigDecimal price, int qty) {
        if (status != OrderStatus.NEW) throw new IllegalStateException("只有 NEW 可加項目");
        if (price.signum() <= 0 || qty <= 0) throw new IllegalArgumentException("商品價格或數量錯誤");
        items.add(new OrderItem(productId, price, qty));
    }

    public void pay() {
        if (status != OrderStatus.NEW) throw new IllegalStateException("狀態錯誤");
        if (items.isEmpty()) throw new IllegalStateException("空單不可付款");
        status = OrderStatus.PAID;
    }

    // getters / 不暴露可變集合
}
```

### Mapper（PO ↔ Domain 轉換）

```java
public class OrderMapper {
    public static Order toDomain(OrderPO po, List<OrderItemPO> itemPOs) {
        Order order = Order.create(po.getCustomerId());
        order.setId(po.getId());
        order.setStatus(OrderStatus.valueOf(po.getStatus()));
        order.setCreatedAt(po.getCreatedAt());
        itemPOs.forEach(it -> order.addItem(it.getProductId(), it.getUnitPrice(), it.getQuantity()));
        return order;
    }

    public static OrderPO toPO(Order order) {
        OrderPO po = new OrderPO();
        po.setId(order.getId());
        po.setCustomerId(order.getCustomerId());
        po.setStatus(order.getStatus().name());
        po.setCreatedAt(order.getCreatedAt());
        return po;
    }
}
```

### Repository

```java
public interface OrderRepository {
    Order findById(Long id);
    Long save(Order order);
}
```

```java
@Repository
public class OrderRepositoryImpl implements OrderRepository {
    private final OrderDao orderDao;
    private final OrderItemDao itemDao;

    public OrderRepositoryImpl(OrderDao orderDao, OrderItemDao itemDao) {
        this.orderDao = orderDao;
        this.itemDao = itemDao;
    }

    @Override
    public Order findById(Long id) {
        OrderPO po = orderDao.findById(id);
        List<OrderItemPO> items = itemDao.findByOrderId(id);
        return OrderMapper.toDomain(po, items);
    }

    @Override
    @Transactional
    public Long save(Order order) {
        OrderPO po = OrderMapper.toPO(order);
        if (po.getId() == null) {
            orderDao.insert(po);
        } else {
            orderDao.update(po);
        }
        return po.getId();
    }
}
```

### ✅ **關鍵點**

* **領域模型**與**持久化模型**分離，確保業務規則不被 ORM 註解與資料庫細節污染
* **Mapper**負責轉換，不讓 Service 或 Controller 接觸到 PO
* **Repository**對外只暴露領域模型，內部才使用 DAO 與 PO

---